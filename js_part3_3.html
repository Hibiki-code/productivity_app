<script>
    console.log('Part 3_3 Start');

    // === CONFIG ===
    let currentScheduleDate = new Date(); // Center date
    let scheduleDateCache = {}; // Cache events by dateStr

    // === INIT ===
    function initScheduleView() {
        renderDateStrip();
        loadSchedule(formatDateForApi(currentScheduleDate));
    }

    // === DATE STRIP LOGIC ===
    function renderDateStrip() {
        const container = document.getElementById('schedule-date-strip');
        if (!container) return;
        container.innerHTML = '';

        // Generate +/- 15 days for now (simple implementation since user asked for infinite feel)
        // Ideally we use intersection observer for true infinite scroll, but 30 days is enough buffer 
        // if we re-center on selection.

        const center = new Date(currentScheduleDate);
        const start = new Date(center);
        start.setDate(center.getDate() - 14);

        for (let i = 0; i < 30; i++) {
            const d = new Date(start);
            d.setDate(start.getDate() + i);
            const isToday = isSameDate(d, new Date());
            const isSelected = isSameDate(d, center);

            const el = document.createElement('div');
            el.className = `date-strip-item ${isSelected ? 'selected' : ''} ${isToday ? 'today' : ''}`;
            el.onclick = () => selectScheduleDate(d);

            // Day of week
            const days = ['日', '月', '火', '水', '木', '金', '土'];
            const dayStr = days[d.getDay()];

            el.innerHTML = `
                <div class="ds-day">${dayStr}</div>
                <div class="ds-num">${d.getDate()}</div>
            `;
            container.appendChild(el);

            if (isSelected) {
                setTimeout(() => {
                    el.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
                }, 100);
            }
        }
    }

    function selectScheduleDate(date) {
        currentScheduleDate = new Date(date);
        renderDateStrip(); // Re-render to update selected state & potentially re-center

        const dateStr = formatDateForApi(date);

        // Update Header Date
        const header = document.getElementById('schedule-header-date');
        if (header) {
            const days = ['日', '月', '火', '水', '木', '金', '土'];
            header.innerText = `${date.getMonth() + 1}月${date.getDate()}日 (${days[date.getDay()]})`;
        }

        loadSchedule(dateStr);
    }

    // === DATA LOADING ===
    function loadSchedule(dateStr) {
        const list = document.getElementById('schedule-event-list');
        if (!list) return;

        // Check Cache
        if (scheduleDateCache[dateStr]) {
            renderEvents(scheduleDateCache[dateStr]);
            return;
        }

        list.innerHTML = '<div style="text-align:center; padding:40px; color:#999;">Loading Smart Schedule...<br><span style="font-size:10px;">(Checking Calendars, Habits & Tasks)</span></div>';

        google.script.run.withSuccessHandler((events) => {
            scheduleDateCache[dateStr] = events;
            renderEvents(events);
        }).withFailureHandler((err) => {
            list.innerHTML = `<div style="text-align:center; padding:20px; color:red;">Error: ${err.message}</div>`;
        }).getSmartSchedule(dateStr); // UPDATED FUNCTION
    }

    function renderEvents(events) {
        const list = document.getElementById('schedule-event-list');
        if (!list) return;
        list.innerHTML = '';

        if (!events || events.length === 0) {
            const emptyState = document.createElement('div');
            emptyState.innerHTML = `
                <div style="text-align:center; padding:50px 20px; color:#aaa;">
                    <span class="material-symbols-rounded" style="font-size:48px; color:#eee;">event_busy</span>
                    <div style="margin-top:10px;">予定はありません</div>
                </div>`;
            list.appendChild(emptyState);
            return;
        }

        // Sort: All day first, then by time
        events.sort((a, b) => {
            if (a.isAllDay && !b.isAllDay) return -1;
            if (!a.isAllDay && b.isAllDay) return 1;

            // If times are equal, put real events before generated ones
            const timeDiff = a.time.localeCompare(b.time);
            if (timeDiff !== 0) return timeDiff;

            if (a.type === 'event' && b.type !== 'event') return -1;
            if (a.type !== 'event' && b.type === 'event') return 1;

            return 0;
        });

        events.forEach(e => {
            const card = document.createElement('div');
            card.className = 'event-card';

            // Custom Styling for Auto-Generated items
            if (e.type === 'habit' || e.type === 'task') {
                card.style.borderLeftStyle = 'dashed';
                card.style.borderLeftWidth = '4px';
                card.style.background = '#fcfcfc';
                card.style.opacity = '0.9';
            }

            let timeHtml = '';
            if (e.isAllDay) {
                timeHtml = `<div class="event-time all-day">All Day</div>`;
            } else {
                timeHtml = `<div class="event-time">${e.time}</div>`;
            }

            // Location or Type Label
            let locHtml = '';
            if (e.type === 'habit') {
                locHtml = `<div class="event-loc" style="color:#66bb6a;"><span class="material-symbols-rounded" style="font-size:12px;">auto_awesome</span> おすすめの習慣</div>`;
            } else if (e.type === 'task') {
                locHtml = `<div class="event-loc" style="color:#ffa726;"><span class="material-symbols-rounded" style="font-size:12px;">auto_awesome</span> おすすめのタスク</div>`;
            } else if (e.location) {
                locHtml = `<div class="event-loc"><span class="material-symbols-rounded" style="font-size:12px;">location_on</span> ${e.location}</div>`;
            }

            // Title Icon
            let iconHtml = '';
            if (e.icon) {
                // Use Google Font icon if provided
                // Note: e.icon might be 'star' or 'check_circle'
            }

            card.innerHTML = `
                ${timeHtml}
                <div class="event-details">
                    <div class="event-title" style="display:flex; align-items:center; gap:5px;">
                        ${e.title}
                    </div>
                    ${locHtml}
                </div>
            `;

            // Border color from calendar or type default
            if (e.color) {
                card.style.borderLeft = `4px ${e.type === 'event' ? 'solid' : 'dashed'} ${e.color}`;
            }

            list.appendChild(card);
        });
    }

    // === UTILS ===
    function formatDateForApi(d) {
        const y = d.getFullYear();
        const m = String(d.getMonth() + 1).padStart(2, '0');
        const day = String(d.getDate()).padStart(2, '0');
        return `${y}-${m}-${day}`;
    }

    function isSameDate(d1, d2) {
        return d1.getFullYear() === d2.getFullYear() &&
            d1.getMonth() === d2.getMonth() &&
            d1.getDate() === d2.getDate();
    }

    // === GEMINI CHAT LOGIC ===
    function toggleGeminiChat() {
        const overlay = document.getElementById('gemini-chat-overlay');
        const fab = document.getElementById('gemini-fab');
        if (!overlay) return;

        const isOpen = overlay.style.bottom === '0px';
        if (isOpen) {
            overlay.style.bottom = '-100%';
            fab.style.transform = 'scale(1)';
        } else {
            overlay.style.bottom = '0px';
            fab.style.transform = 'scale(0)'; // Hide FAB when open
            // Focus input
            setTimeout(() => document.getElementById('gemini-input').focus(), 300);
        }
    }

    function sendGeminiMessage() {
        const input = document.getElementById('gemini-input');
        const container = document.getElementById('gemini-messages');
        const text = input.value.trim();
        if (!text) return;

        // 1. Add User Message
        appendMessage(text, 'user');
        input.value = '';
        input.style.height = 'auto'; // Reset height

        // 2. Show Loading
        const loadingId = 'loading-' + Date.now();
        appendLoading(loadingId);

        // 3. Prepare Payload
        // Simple history for now: just current message. 
        // Logic could be expanded to include previous messages.
        const messages = [
            { role: "user", parts: [{ text: text }] }
        ];

        // 4. Call Backend
        google.script.run.withSuccessHandler((response) => {
            removeLoading(loadingId);
            appendMessage(response, 'ai');
        }).withFailureHandler((err) => {
            removeLoading(loadingId);
            appendMessage("Error: " + err.message, 'ai');
        }).callGeminiAPI(messages);
    }

    function appendMessage(text, type) {
        const container = document.getElementById('gemini-messages');
        const div = document.createElement('div');
        div.className = `chat-msg ${type}`;

        // Style Logic inline for simplicity or use CSS classes
        const baseStyle = "padding:12px 16px; border-radius:18px; font-size:14px; line-height:1.5; max-width:85%; word-wrap:break-word;";
        const userStyle = "align-self:flex-end; background:#4285f4; color:white; border-bottom-right-radius:4px;";
        const aiStyle = "align-self:flex-start; background:white; color:#333; border-bottom-left-radius:4px; box-shadow:0 1px 2px rgba(0,0,0,0.05);";

        div.style.cssText = baseStyle + (type === 'user' ? userStyle : aiStyle);

        // Simple Markdown parsing for AI checks
        if (type === 'ai') {
            // Convert **bold** to <b>
            let html = text.replace(/\*\*(.*?)\*\*/g, '<b>$1</b>');
            html = html.replace(/\n/g, '<br>');
            div.innerHTML = html;
        } else {
            div.innerText = text;
        }

        container.appendChild(div);
        container.scrollTop = container.scrollHeight;
    }

    function appendLoading(id) {
        const container = document.getElementById('gemini-messages');
        const div = document.createElement('div');
        div.id = id;
        div.className = 'chat-msg ai';
        div.style.cssText = "align-self:flex-start; background:white; padding:12px 16px; border-radius:18px; border-bottom-left-radius:4px; box-shadow:0 1px 2px rgba(0,0,0,0.05); color:#999; font-size:12px;";
        div.innerHTML = '<span class="material-symbols-rounded" style="font-size:16px; animation:spin 1s linear infinite;">progress_activity</span> Thinking...';
        container.appendChild(div);
        container.scrollTop = container.scrollHeight;
    }

    function removeLoading(id) {
        const el = document.getElementById(id);
        if (el) el.remove();
    }

    // Auto-resize textarea
    document.addEventListener('DOMContentLoaded', () => {
        const input = document.getElementById('gemini-input');
        if (input) {
            input.addEventListener('input', function () {
                this.style.height = 'auto';
                this.style.height = (this.scrollHeight) + 'px';
            });
            // Enter to send
            input.addEventListener('keydown', function (e) {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendGeminiMessage();
                }
            });
        }
    });

    console.log('Part 3_3 End');
</script>