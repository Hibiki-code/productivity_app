<script>
    // --- CRITICAL GLOBAL FUNCTIONS (Defined Early) ---
    window.activeGoalDetailId = null;
    window.activeGoalDetailData = null;

    window.openGoalDetail = function (goalId) {
        console.log('Switching to Goal Detail Page:', goalId);
        window.activeGoalDetailId = goalId;

        const goal = (window.loadedGoals || []).find(g => g.id === goalId);
        if (!goal) {
            console.error('Goal data not found for id:', goalId);
            return;
        }
        window.activeGoalDetailData = goal;

        // Populate New View Elements
        document.getElementById('gd-page-title').innerText = goal.title;

        // Vision with Edit Icon (In-Place)
        const visionText = goal.vision || 'No vision defined.';
        const visionHtml = `
            <div style="position:relative; padding-right:20px;">
                <div id="gd-vision-text" contenteditable="true" 
                     onblur="saveVisionInline('${goal.id}', this)"
                     style="outline:none; white-space:pre-wrap; min-height:20px;">${visionText}</div>
                <div onclick="document.getElementById('gd-vision-text').focus()" 
                     style="position:absolute; bottom:-5px; right:-5px; cursor:pointer; color:#ccc; padding:5px;">
                    <span class="material-symbols-rounded" style="font-size:16px;">edit</span>
                </div>
            </div>
        `;
        document.getElementById('gd-vision-card').innerHTML = visionHtml;

        const current = Number(goal.metricCurrent) || 0;
        const target = Number(goal.metricTarget) || 0;
        document.getElementById('gd-current-val').innerText = current + (goal.metricLabel || '');
        document.getElementById('gd-target-val').innerText = '/ ' + target + (goal.metricLabel || '');
        const percent = (target > 0) ? Math.min(100, Math.max(0, (current / target) * 100)) : 0;
        document.getElementById('gd-progress-fill').style.width = percent + '%';

        // Load History
        document.getElementById('gd-history-list').innerHTML = '<div class="spinner"></div>';
        google.script.run.withSuccessHandler(window.renderGoalHistory).getGoalHistory(goalId);

        // Switch View
        document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
        document.getElementById('view-goal-detail').classList.add('active');
    };

    window.closeGoalDetail = function () {
        window.activeGoalDetailId = null;
        window.activeGoalDetailData = null;

        // Hide detail, show roadmap
        document.getElementById('view-goal-detail').classList.remove('active');
        document.getElementById('view-roadmap').classList.add('active');
    };

    window.saveVisionInline = function (id, element) {
        const newText = element.innerText;
        // Visual indicator
        element.style.color = '#aaa';

        google.script.run.withSuccessHandler(() => {
            element.style.color = ''; // Restore
            // Optional: Toast "Saved"
        }).updateGoalVision(id, newText);
    };

    window.renderGoalHistory = function (history) {
        const container = document.getElementById('gd-history-list');
        container.innerHTML = '';

        if (!history || history.length === 0) {
            container.innerHTML = '<div style="text-align:center; color:#ccc; font-size:12px; padding:20px;">Â±•Ê≠¥„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì</div>';
            return;
        }

        history.forEach(log => {
            const d = new Date(log.date);
            // Format: 2024/01/01 12:00
            const dateStr = `${d.getFullYear()}/${(d.getMonth() + 1).toString().padStart(2, '0')}/${d.getDate().toString().padStart(2, '0')} ${d.getHours().toString().padStart(2, '0')}:${d.getMinutes().toString().padStart(2, '0')}`;

            const div = document.createElement('div');
            div.className = 'history-card';
            div.style.background = 'white';
            div.style.padding = '15px';
            div.style.borderRadius = '16px';
            div.style.boxShadow = '0 2px 8px rgba(0,0,0,0.03)';
            div.style.border = '1px solid rgba(0,0,0,0.03)';
            div.style.display = 'flex';
            div.style.flexDirection = 'column';
            div.style.gap = '8px';

            div.innerHTML = `
            <div style="font-size:11px; color:#aaa; font-family:monospace;">${dateStr}</div>
            
            <div style="display:flex; align-items:baseline; gap:6px;">
                 <span style="font-size:12px; color:#666;">ÈÅîÊàêÂÄ§:</span>
                 <span style="font-size:18px; font-weight:800; color:#333;">${log.value}</span>
            </div>
            
            ${log.notes ? `
            <div style="background:#f9f9f9; padding:10px; border-radius:8px; font-size:13px; color:#555; line-height:1.5; margin-top:2px; position:relative;">
                ${log.notes}
                <div onclick="openEditNoteModal('${log.id}', '${log.notes.replace(/'/g, "\\'")}')" 
                     style="position:absolute; bottom:5px; right:5px; cursor:pointer; color:#ccc; padding:2px;">
                    <span class="material-symbols-rounded" style="font-size:14px;">edit</span>
                </div>
            </div>` : `
            <div onclick="openEditNoteModal('${log.id}', '')" 
                 style="text-align:right; font-size:11px; color:#ddd; cursor:pointer; margin-top:2px;">
                <span class="material-symbols-rounded" style="font-size:14px;">edit</span>
            </div>
            `}
        `;
            container.appendChild(div);
        });
    };

    /* --- EDIT NOTE LOGIC --- */
    function openEditNoteModal(id, currentText) {
        document.getElementById('en-id').value = id;
        document.getElementById('en-text').value = currentText; // Decode? It's raw text.

        const modal = document.getElementById('edit-note-modal');
        modal.classList.add('open');
        modal.style.display = 'flex';

        setTimeout(() => document.getElementById('en-text').focus(), 100);
    }

    function closeEditNoteModal() {
        const modal = document.getElementById('edit-note-modal');
        modal.classList.remove('open');
        modal.style.display = 'none';
    }

    function saveEditedNote() {
        const id = document.getElementById('en-id').value;
        const text = document.getElementById('en-text').value;

        closeEditNoteModal();

        // Optimistic Update (Optional, but let's just reload history for simplicity)
        const historyContainer = document.getElementById('gd-history-list');
        historyContainer.innerHTML = '<div class="spinner"></div>';

        google.script.run.withSuccessHandler((res) => {
            // Reload History
            google.script.run.withSuccessHandler(window.renderGoalHistory).getGoalHistory(window.activeGoalDetailId);
        }).updateHistoryNote(id, text);
    }

    /* --- EDIT VISION LOGIC --- */
    function openEditVisionModal(id, currentText) {
        document.getElementById('ev-id').value = id;
        document.getElementById('ev-text').value = currentText;

        const modal = document.getElementById('edit-vision-modal');
        modal.classList.add('open');
        modal.style.display = 'flex';

        setTimeout(() => document.getElementById('ev-text').focus(), 100);
    }

    function closeEditVisionModal() {
        const modal = document.getElementById('edit-vision-modal');
        modal.classList.remove('open');
        modal.style.display = 'none';
    }

    function saveEditedVision() {
        const id = document.getElementById('ev-id').value;
        const text = document.getElementById('ev-text').value;

        closeEditVisionModal();

        // Optimistic Update?
        // Let's just reload the page/view since it's the main data
        // Or update DOM directly for speed
        document.getElementById('gd-vision-card').innerHTML = `<div class="spinner">Updating...</div>`;

        google.script.run.withSuccessHandler((res) => {
            // Re-fetch everything to ensure sync, or just re-open
            // Ideally we re-fetch goals to update global 'loadedGoals'
            google.script.run.withSuccessHandler((goals) => {
                window.loadedGoals = goals;
                // Restore Detail View
                window.openGoalDetail(id);
            }).getGoalsV2();
        }).updateGoalVision(id, text);
    }

    /* --- EXPOSE TO GLOBAL (Fix for Scope Issues) --- */
    window.openGoalModal = openGoalModal;
    window.closeGoalModal = closeGoalModal;
    window.saveGoal = saveGoal;
    window.openMeasurementModal = openMeasurementModal;
    window.openEditNoteModal = openEditNoteModal; // Keep history edit
    window.closeEditNoteModal = closeEditNoteModal;
    window.saveEditedNote = saveEditedNote;
    window.openEditVisionModal = openEditVisionModal; // New
    window.closeEditVisionModal = closeEditVisionModal;
    window.saveEditedVision = saveEditedVision;
    window.openProgressFromDetailPage = openProgressFromDetailPage;

    // --- NAVIGATION HELPERS (Global) ---
    window.showTab = function (id) {
        document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
        const view = document.getElementById('view-' + id);
        if (view) view.classList.add('active');

        document.querySelectorAll('.nav-item').forEach(n => {
            n.classList.remove('active');
            if (n.innerHTML.includes(id) || (id === 'tasks' && n.innerHTML.includes('done_all')) || (id === 'habits' && n.innerHTML.includes('water_drop'))) {
                n.classList.add('active');
            }
        });
    };

    window.switchTab = function (id, el) {
        document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
        document.getElementById('view-' + id).classList.add('active');
        document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
        if (el) el.classList.add('active');

        if (id === 'goals' && window.renderGoalsTab) {
            window.renderGoalsTab();
        }
        if (id === 'roadmap' && window.renderRoadmap) {
            window.renderRoadmap();
        }
    };

    // --- STATE ---
    let currentHabitDate = new Date().toLocaleDateString('en-CA');
    let habitCalendarCache = {};
    let currentDetailHabit = null; // Object
    let currentDetailYear = 0;
    let currentDetailMonth = 0;
    let todayYear = 0; // RESTORED
    let todayMonth = 0; // RESTORED

    let activeGoalDetailId = null;
    let activeGoalDetailData = null;
    let habitDataCache = null; // { habits: [], sections: [] } for re-rendering

    // --- INIT ---
    window.onload = function () {
        console.log("App Started v2026-01-05-1305 FIXED_SSR_TAGS");
        // Check for Debug Errors
        let ssrError = null;
        try {
            const errTag = document.getElementById('ssr-data-error');
            if (errTag) {
                const val = errTag.textContent;
                if (val && val !== 'null' && val !== '"null"') {
                    ssrError = JSON.parse(val);
                }
            }
        } catch (e) { console.error("Error parsing SSR error", e); }

        if (ssrError) {
            const errDiv = document.createElement('div');
            errDiv.style.background = '#ffebee';
            errDiv.style.color = '#c62828';
            errDiv.style.padding = '10px';
            errDiv.style.borderBottom = '1px solid #ef5350';
            errDiv.innerText = ssrError;
            document.body.prepend(errDiv);
        }

        // Force Migration Button Visibility
        const btn = document.getElementById('migration-btn');
        if (btn) document.body.prepend(btn);


        // 1. Render Injected Data (SSR)
        try {
            const tasksTag = document.getElementById('ssr-data-tasks');
            const rawTasks = tasksTag ? JSON.parse(tasksTag.textContent) : [];

            const habitsTag = document.getElementById('ssr-data-habits');
            const rawHabits = habitsTag ? JSON.parse(habitsTag.textContent) : null;

            if (rawTasks) renderTasks(rawTasks);

            initDateStrip();

            if (rawHabits) {
                renderHabits(rawHabits);
            } else {
                // Fallback
                fetchHabits(new Date().toLocaleDateString('en-CA'));
            }
        } catch (e) {
            console.error("SSR Parse Error", e);
            fetchTasks();
            fetchHabits(new Date().toLocaleDateString('en-CA'));
        }

        setupModal();
        showTab('tasks');
    };

    // Programmatic Tab Switch
    function showTab(id) {
        // Manual Switch without 'el' dependency if el not found
        document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
        const view = document.getElementById('view-' + id);
        if (view) view.classList.add('active');

        document.querySelectorAll('.nav-item').forEach(n => {
            n.classList.remove('active');
            // Try to match
            if (n.innerHTML.includes(id) || (id === 'tasks' && n.innerHTML.includes('done_all')) || (id === 'habits' && n.innerHTML.includes('water_drop'))) {
                n.classList.add('active');
            }
        });

        if (id === 'habits') {
            // Refresh habits
            // fetchHabits(new Date().toLocaleDateString('en-CA')); // Optional
        }
    }

    function setupModal() {
        // Close Modals on Overlay Click
        document.querySelectorAll('.modal-overlay').forEach(overlay => {
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    overlay.classList.remove('open');
                    overlay.style.display = 'none'; // Fallback
                }
            });
        });

        // Task Modal
        const taskModal = document.getElementById('task-modal');
        if (taskModal) {
            taskModal.addEventListener('click', e => {
                if (e.target === taskModal) closeTaskModal();
            });
        }
    }

    function switchTab(id, el) {
        document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
        document.getElementById('view-' + id).classList.add('active');
        document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
        el.classList.add('active');

        if (id === 'habits') {
            // Maybe refresh habits to be sure
        }
        if (id === 'goals') {
            renderGoalsTab();
        }
    }

    // --- TASKS ---
    function fetchTasks() {
        // Still useful for manual refresh
        google.script.run.withSuccessHandler(renderTasks).getTasks();
    }

    /* --- TASK LOGIC REFACTOR (Edit/Add) --- */

    let tasksCache = []; // Global Cache

    function renderTasks(tasks) {
        console.log('Rendering Tasks:', tasks.length);
        tasksCache = tasks; // Cache for editing
        try {
            // Clear
            const lists = ['high', 'med', 'low', 'none', 'done'];
            lists.forEach(k => {
                const el = document.querySelector('#list-' + k + ' > div');
                if (el) el.innerHTML = '';
            });
            let counts = { 3: 0, 2: 0, 1: 0, 0: 0, done: 0 };

            tasks.forEach(t => {
                const p = Number(t.importance) || 0;
                const status = (t.status || '').trim();

                if (status === 'ÂÆå‰∫Ü') {
                    counts.done++;
                    createTaskEl(t, 'list-done');
                } else {
                    counts[p]++;
                    const map = { 3: 'high', 2: 'med', 1: 'low', 0: 'none' };
                    createTaskEl(t, 'list-' + map[p]);
                }
            });

            // Update counts
            if (document.getElementById('count-high')) document.getElementById('count-high').innerText = counts[3];
            if (document.getElementById('count-med')) document.getElementById('count-med').innerText = counts[2];
            if (document.getElementById('count-low')) document.getElementById('count-low').innerText = counts[1];
            if (document.getElementById('count-none')) document.getElementById('count-none').innerText = counts[0];
            if (document.getElementById('count-done')) document.getElementById('count-done').innerText = counts.done;

            const doneSec = document.getElementById('sec-done');
            if (doneSec) doneSec.style.display = counts.done > 0 ? 'block' : 'none';

            initTaskSortables(); // Init Drag & Drop

        } catch (e) {
            console.error('Error rendering tasks:', e);
        }
    }

    // Updated Tap Handler
    function handleTaskTap(e, taskObj) {
        if (isHighlightMode) {
            e.preventDefault();
            e.stopPropagation();
            const id = taskObj.dataset.id;
            showHighlightConfirm(id);
            return;
        }

        // Edit Mode
        const id = taskObj.dataset.id;
        const task = tasksCache.find(t => t.id === id);

        console.log('Tap Task:', id, task); // Debug

        if (task) {
            openEditTaskModal(task);
        } else {
            console.warn('Task not found in cache:', id);
            // Fallback: Try to fetch or just ignore?
        }
    }

    function saveTask() {
        const modal = document.getElementById('task-modal');
        const mode = modal.dataset.mode || 'add';
        const id = document.getElementById('t-id').value;
        const name = document.getElementById('t-name').value;
        const prio = document.getElementById('t-prio').value;

        // Inputs
        const durH = document.getElementById('t-duration-h').value || 0;
        const durM = document.getElementById('t-duration-m').value || 0;
        const date = document.getElementById('t-date').value;
        const details = document.getElementById('t-details').value;

        if (!name) return;

        // Format Duration
        let durStr = '';
        if (durH > 0) durStr += durH + 'h ';
        if (durM > 0 || durH > 0) durStr += durM + 'm';

        // Construct Data
        const taskData = {
            id: id,
            name: name,
            importance: prio,
            estTime: durStr.trim(),
            dueDate: date,
            description: details
        };

        console.log('Save Task | Mode:', mode, 'ID:', id, 'Data:', taskData);

        if (mode === 'edit') {
            if (!id) {
                alert('„Ç®„É©„Éº: Á∑®ÈõÜ‰∏≠„ÅÆ„Çø„Çπ„ÇØID„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ');
                return;
            }
            closeTaskModal();

            // Optimistic Update
            const oldTaskIndex = tasksCache.findIndex(t => t.id === id);
            if (oldTaskIndex >= 0) {
                // Merge Data
                const mergedTask = { ...tasksCache[oldTaskIndex], ...taskData };
                tasksCache[oldTaskIndex] = mergedTask;

                // Remove Old Element (To handle priority change which moves list)
                const oldElWrapper = document.querySelector(`.task-wrapper[data-id="${id}"]`);
                if (oldElWrapper) oldElWrapper.remove();

                // Re-create Element in Correct List
                // Priority logic from createTaskEl
                const map = { 3: 'high', 2: 'med', 1: 'low', 0: 'none' };
                // If status is done, it goes to done list (handled by createTaskEl checking status)
                // BUT createTaskEl takes listId as arg.
                // If status is 'ÂÆå‰∫Ü', we should pass 'list-done'.
                let targetListId = 'list-' + map[mergedTask.importance];
                if (mergedTask.status === 'ÂÆå‰∫Ü') targetListId = 'list-done';

                createTaskEl(mergedTask, targetListId);

                // Update Counts
                updateTaskCounts();
            }

            // Update Backend
            google.script.run.withSuccessHandler(() => {
                // Optional: fetchTasks(); // Consistency check, maybe skip if confident
                console.log('Backend Updated');
            }).updateTaskDetails(taskData);

        } else {
            // Add
            closeTaskModal();
            const t = {
                ...taskData,
                status: 'Êú™ÂÆå‰∫Ü',
                row: 'temp-' + Date.now()
            };
            const map = { 3: 'high', 2: 'med', 1: 'low', 0: 'none' };
            createTaskEl(t, 'list-' + map[prio]);
            google.script.run.withSuccessHandler(fetchTasks).addTask(t);
        }
    }

    function openAddTaskModal(p) {
        const modal = document.getElementById('task-modal');
        modal.dataset.mode = 'add';

        // Explicitly Title
        const titleEl = document.getElementById('modal-title-task');
        if (titleEl) titleEl.innerText = '„Çø„Çπ„ÇØËøΩÂä†';

        const btnEl = document.getElementById('btn-save-task');
        if (btnEl) btnEl.innerText = 'ËøΩÂä†';

        document.getElementById('t-id').value = '';

        document.getElementById('t-prio').value = (p !== undefined) ? p : 1;

        // Reset Fields
        document.getElementById('t-name').value = '';
        document.getElementById('t-duration-h').value = '';
        document.getElementById('t-duration-m').value = '15';
        document.getElementById('t-date').value = '';
        document.getElementById('t-details').value = '';

        modal.classList.add('open');
        modal.style.display = 'flex';

        setTimeout(() => document.getElementById('t-name').focus(), 100);
    }

    function openEditTaskModal(task) {
        const modal = document.getElementById('task-modal');
        modal.dataset.mode = 'edit';

        // Explicit title
        const titleEl = document.getElementById('modal-title-task');
        if (titleEl) titleEl.innerText = '„Çø„Çπ„ÇØÁ∑®ÈõÜ';

        const btnEl = document.getElementById('btn-save-task');
        if (btnEl) btnEl.innerText = '‰øùÂ≠ò';

        console.log('Opening Edit Modal for:', task.id);
        const idInput = document.getElementById('t-id');
        idInput.value = task.id;

        document.getElementById('t-name').value = task.name;
        document.getElementById('t-prio').value = task.importance;
        document.getElementById('t-date').value = task.dueDate ? task.dueDate.replace(/\//g, '-') : '';
        document.getElementById('t-details').value = task.description || '';

        let h = 0, m = 15;
        if (task.estTime) {
            const hMatch = task.estTime.match(/(\d+)h/);
            const mMatch = task.estTime.match(/(\d+)m/);
            if (hMatch) h = parseInt(hMatch[1]);
            if (mMatch) m = parseInt(mMatch[1]);
            else if (!hMatch && !mMatch && parseInt(task.estTime)) m = parseInt(task.estTime);
        }
        document.getElementById('t-duration-h').value = (h > 0) ? h : '';
        document.getElementById('t-duration-m').value = m;

        modal.classList.add('open');
        modal.style.display = 'flex';
    }

    // Wrapper for legacy calls if any
    function openTaskModal(p) {
        openAddTaskModal(p);
    }

    function closeTaskModal() {
        const modal = document.getElementById('task-modal');
        modal.classList.remove('open');
        modal.style.display = 'none';
    }

    let taskSortables = [];

    function initTaskSortables() {
        // Clean old
        taskSortables.forEach(s => s.destroy());
        taskSortables = [];

        const lists = ['high', 'med', 'low', 'none'];
        lists.forEach(k => {
            const el = document.querySelector('#list-' + k + ' > div');
            if (!el) return;

            const s = Sortable.create(el, {
                group: 'tasks',
                delay: 200, // Long press 200ms
                delayOnTouchOnly: true,
                animation: 150,
                ghostClass: 'sortable-ghost',
                dragClass: 'sortable-drag',
                onEnd: function (evt) {
                    const item = evt.item;
                    const toList = evt.to.closest('.list-content').id; // list-high
                    const fromList = evt.from.closest('.list-content').id;

                    if (toList === fromList) return; // Same list

                    const map = { 'list-high': 3, 'list-med': 2, 'list-low': 1, 'list-none': 0 };
                    const newPrio = map[toList] !== undefined ? map[toList] : 0;

                    // Update Data
                    item.dataset.prio = newPrio;

                    // Update Counts Logic
                    updateTaskCounts();

                    // Backend Update
                    const row = item.dataset.row;
                    google.script.run.updateTaskPriority(row, newPrio);
                }
            });
            taskSortables.push(s);
        });
    }

    function updateTaskCounts() {
        const counts = { 3: 0, 2: 0, 1: 0, 0: 0 };
        // Valid lists only
        ['list-high', 'list-med', 'list-low', 'list-none'].forEach(id => {
            const container = document.querySelector('#' + id + ' > div');
            const count = container ? container.children.length : 0;
            // Map id to prio
            const pMap = { 'list-high': 3, 'list-med': 2, 'list-low': 1, 'list-none': 0 };
            counts[pMap[id]] = count;
        });

        // Done count is static unless moved
        const doneCount = document.querySelector('#list-done > div').children.length;

        if (document.getElementById('count-high')) document.getElementById('count-high').innerText = counts[3];
        if (document.getElementById('count-med')) document.getElementById('count-med').innerText = counts[2];
        if (document.getElementById('count-low')) document.getElementById('count-low').innerText = counts[1];
        if (document.getElementById('count-none')) document.getElementById('count-none').innerText = counts[0];
        if (document.getElementById('count-done')) document.getElementById('count-done').innerText = doneCount;
    }

    /* --- HIGHLIGHT LOGIC --- */
    let isHighlightMode = false;

    function toggleHighlightMode() {
        isHighlightMode = !isHighlightMode;
        const btn = document.getElementById('highlight-mode-btn');
        if (btn) {
            btn.style.opacity = isHighlightMode ? '1' : '0.4';
            btn.style.transform = isHighlightMode ? 'scale(1.2)' : 'scale(1.0)';
        }
        document.body.classList.toggle('highlight-mode-active', isHighlightMode);
    }

    function handleTaskTap(e, taskObj) {
        if (isHighlightMode) {
            e.preventDefault();
            e.stopPropagation();
            const id = taskObj.dataset.id;
            showHighlightConfirm(id);
            return;
        }

        // Edit Mode
        const id = taskObj.dataset.id;
        const task = tasksCache.find(t => t.id === id);
        if (task) {
            openEditTaskModal(task);
        }
    }

    function showHighlightConfirm(id) {
        if (confirm('„Åì„ÅÆ„Çø„Çπ„ÇØ„Çí„Äå‰ªäÊó•„ÅÆ„Éè„Ç§„É©„Ç§„Éà„Äç„Å´Ë®≠ÂÆö„Åó„Åæ„Åô„ÅãÔºü')) {
            doSetHighlight(id);
            toggleHighlightMode();
        }
    }

    function doSetHighlight(id) {
        // Optimistic UI updates
        document.querySelectorAll('.highlight-diamond').forEach(el => el.remove());

        const item = document.querySelector(`.task-item[data-id="${id}"] .task-content`);
        if (item) {
            const d = document.createElement('div');
            d.className = 'highlight-diamond';
            d.innerText = 'üíé';
            item.prepend(d); // Add to UI

            google.script.run.withSuccessHandler(() => {
            }).setDailyHighlight(id);
        }
    }

    /* --- TASK CREATION --- */
    function createTaskEl(t, listId) {
        const list = document.getElementById(listId);
        if (!list) return;

        const doneClass = t.status === 'ÂÆå‰∫Ü' ? 'done' : '';
        const checkMark = t.status === 'ÂÆå‰∫Ü' ? '‚úì' : '';
        const highlightIcon = t.isHighlight ? `<div class="highlight-diamond" style="font-size:18px; margin-right:5px;">üíé</div>` : '';
        const isCompleted = (t.status === 'ÂÆå‰∫Ü');

        const div = document.createElement('div');
        div.className = 'task-wrapper';
        div.dataset.id = t.id;

        div.innerHTML = `
        <div class="task-actions right" style="position:absolute; top:0; left:0; right:0; width:100%; height:100%; display:flex; justify-content:flex-end; align-items:center; z-index:1; visibility: hidden; opacity: 1; pointer-events: none;">
           <div class="action-btn archive-btn" onclick="doArchiveTask('${t.id}')" style="pointer-events: auto; background:#5E6CD8 !important; width:50px !important; min-width:50px !important; max-width:50px !important; flex: 0 0 50px !important; height:100%; display:flex; align-items:center; justify-content:center; color:white; border-radius:0; margin:0; padding:0;">
             <span class="material-symbols-rounded" style="font-size: 24px;">archive</span>
           </div>
           <div class="action-btn delete-btn" style="pointer-events: auto; background:#FF5252 !important; width:50px !important; min-width:50px !important; max-width:50px !important; flex: 0 0 50px !important; height:100%; display:flex; align-items:center; justify-content:center; color:white; border-radius:0; margin:0; padding:0;" onclick="doDeleteTask('${t.id}')">
             <span class="material-symbols-rounded" style="font-size: 24px;">delete</span>
           </div>
        </div>

        <div class="task-item ${doneClass}" data-id="${t.id}" data-prio="${t.importance}" onclick="handleTaskTap(event, this)">
          <div class="task-check"
            ontouchstart="toggleTask(event, this); event.preventDefault();"
            onclick="if(!event.defaultPrevented) toggleTask(event, this);">
            ${checkMark}
          </div>

          <div class="task-content">
            <div class="test-tag"></div>
            ${highlightIcon}
            <div class="task-name">${t.name}</div>
            <div class="task-meta">
              ${t.dueDate ? `<span class="due-date">üìÖ ${t.dueDate.slice(5)}</span>` : ''}
              ${t.estTime ? `<span class="est-time">‚è± ${t.estTime}</span>` : ''}
            </div>
          </div>
        </div>
      `;

        const item = div.querySelector('.task-item');
        addSwipeLogic(item);

        div.style.opacity = '0';
        div.style.transform = 'translateY(10px)';
        if (isCompleted) {
            list.querySelector('div').prepend(div);
        } else {
            list.querySelector('div').appendChild(div);
        }

        requestAnimationFrame(() => {
            div.style.transition = 'all 0.3s ease';
            div.style.opacity = '1';
            div.style.transform = 'translateY(0)';

            // Clear transform after animation to avoid stacking context issues
            setTimeout(() => {
                div.style.transform = '';
            }, 350);
        });
    }

    // --- SWIPE LOGIC ---
    let openSwipes = []; // Track open elements

    function doUnarchiveTask(id) {
        if (!confirm('„Çø„Çπ„ÇØ„Çí„É™„Çπ„Éà„Å´Êàª„Åó„Åæ„Åô„ÅãÔºü')) return;
        removeEl(id);
        google.script.run.unarchiveTask(id);
    }

    function addSwipeLogic(el) {
        let startX = 0;
        let currentTranslate = 0;
        let isDragging = false;
        const actionsEl = el.parentElement.querySelector('.task-actions');

        el.addEventListener('touchstart', e => {
            startX = e.touches[0].clientX;
            el.style.transition = 'none';
            closeAllSwipes(el); // Standard behavior
        }, { passive: true });

        el.addEventListener('touchmove', e => {
            const currentX = e.touches[0].clientX;
            const diff = currentX - startX;

            // Dead Zone & Direction Lock (Only allow left swipe)
            if (diff > 0 && !el.classList.contains('swiped-open')) return;
            if (Math.abs(diff) < 10) return;

            // Show actions when swiping starts
            if (actionsEl && diff < 0) actionsEl.style.visibility = 'visible';

            // Simple Translation (Limit to negative or zero)
            const trans = Math.min(0, diff);
            el.style.transform = `translateX(${trans}px)`;
            currentTranslate = trans;
            isDragging = true;
        }, { passive: true });

        el.addEventListener('touchend', e => {
            el.style.transition = 'transform 0.2s ease-out';
            isDragging = false;

            // Snap Logic - Right Side Only (Threshold 50px for 50px buttons)
            if (currentTranslate < -50) {
                // Open Right (reveals buttons)
                el.style.transform = 'translateX(-100px)'; // 2 * 50px = 100px
                el.classList.add('swiped-open');
                if (actionsEl) actionsEl.style.visibility = 'visible';
            } else {
                closeSwipe(el);
            }
            currentTranslate = 0;
        });
    }

    function closeSwipe(el) {
        el.style.transform = `translateX(0)`;
        el.classList.remove('swiped-open');

        // Hide actions after animation to fix transparency leak
        const actionsEl = el.parentElement.querySelector('.task-actions');
        if (actionsEl) {
            setTimeout(() => {
                actionsEl.style.visibility = 'hidden';
            }, 250); // Match transition length
        }
    }

    function closeAllSwipes(exceptEl) {
        document.querySelectorAll('.task-item.swiped-open').forEach(el => {
            if (el !== exceptEl) closeSwipe(el);
        });
    }

    // Tap Outside Listener
    document.addEventListener('touchstart', (e) => {
        // If target is NOT a task-item or child of swiped-open, close all
        if (!e.target.closest('.task-item.swiped-open') && !e.target.closest('.action-btn')) {
            closeAllSwipes(null);
        }
    });

    function doArchiveTask(id) {
        if (!confirm('„Åì„ÅÆ„Çø„Çπ„ÇØ„Çí„Ç¢„Éº„Ç´„Ç§„Éñ„Åó„Åæ„Åô„ÅãÔºü')) return;
        removeEl(id);
        google.script.run.archiveTask(id);
    }

    function doDeleteTask(id) {
        if (!confirm('„Åì„ÅÆ„Çø„Çπ„ÇØ„ÇíÂÆåÂÖ®„Å´ÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü(Âæ©ÂÖÉ„Åß„Åç„Åæ„Åõ„Çì)')) return;
        removeEl(id);
        google.script.run.deleteTaskHard(id); // Hard Delete
    }

    function removeEl(id) {
        const wrapper = document.querySelector(`.task-wrapper[data-id="${id}"]`);
        if (wrapper) {
            wrapper.style.height = wrapper.offsetHeight + 'px';
            wrapper.style.transition = 'height 0.3s, opacity 0.3s';
            setTimeout(() => {
                wrapper.style.height = '0';
                wrapper.style.opacity = '0';
                setTimeout(() => wrapper.remove(), 300);
            }, 10);
        }
    }

    // Legacy mapping (if used elsewhere)
    function deleteTask(id) { doDeleteTask(id); }
    function editTask(id) { alert('Edit disabled'); } // cleanup later

    function toggleSection(id) {
        const list = document.getElementById('list-' + id);
        if (!list) return;

        // Logic: Toggle 'collapsed' class on list ONLY
        list.classList.toggle('collapsed');
    }


    function toggleDetails(header) {
        const item = header.closest('.task-item');
        const details = item.querySelector('.task-details');
        const icon = item.querySelector('.task-icon');

        if (details.style.display === 'none') {
            details.style.display = 'block';
            icon.innerText = '‚àß';
            icon.style.color = '#333';
        } else {
            details.style.display = 'none';
            icon.innerText = '‚ãÅ';
            icon.style.color = '#CCC';
        }
    }

    function toggleTask(e, checkEl) {
        e.stopPropagation();

        const item = checkEl.closest('.task-item');
        if (!item) return;

        const wrapper = item.closest('.task-wrapper') || item;
        const id = item.dataset.id;
        // Determine new status (if currently done, make undone)
        const isDoneCurrently = item.classList.contains('done');
        const isDoneNew = !isDoneCurrently;

        // 1. Immediate Visual Update (Checkmark only)
        if (isDoneNew) {
            checkEl.innerText = '‚úì';
            item.classList.add('done'); // Style update immediately
        } else {
            checkEl.innerText = '';
            item.classList.remove('done');
        }

        // Add Leave Animation
        wrapper.classList.add('task-anim-leave');

        // Wait for Animation
        setTimeout(() => {
            wrapper.classList.remove('task-anim-leave');

            // 2. List Move Logic
            const p = item.dataset.prio || 0;
            const map = { 3: 'high', 2: 'med', 1: 'low', 0: 'none' };
            const key = map[p];

            // Update Counts
            const countEl = document.getElementById('count-' + key);
            const doneCountEl = document.getElementById('count-done');
            let val = parseInt(countEl.innerText.match(/\d+/)[0]) || 0;
            let doneVal = parseInt(doneCountEl.innerText.match(/\d+/)[0]) || 0;

            if (isDoneNew) {
                // Move to Done Top
                const doneContainer = document.querySelector('#list-done > div');
                if (doneContainer) {
                    doneContainer.prepend(wrapper);
                    countEl.innerText = Math.max(0, val - 1);
                    doneCountEl.innerText = doneVal + 1;
                    const secDone = document.getElementById('sec-done');
                    if (secDone) secDone.style.display = 'block';
                }
            } else {
                // Move back to List
                const sourceContainer = document.querySelector('#list-' + key + ' > div');
                if (sourceContainer) {
                    sourceContainer.appendChild(wrapper);
                    countEl.innerText = val + 1;
                    doneCountEl.innerText = Math.max(0, doneVal - 1);
                }
            }

            // Animate Enter
            wrapper.classList.add('task-anim-enter');
            setTimeout(() => wrapper.classList.remove('task-anim-enter'), 400);

            // 3. Server Update
            google.script.run.withSuccessHandler((res) => {
                console.log('Task toggled', res);
            }).updateTaskStatus(id, isDoneNew);

        }, 350);
    }

    // START LEGACY CLEANUP (Removed duplicate saveTask/openTaskModal/closeTaskModal)
    // The correct versions are defined above (approx line 439).
    // END LEGACY CLEANUP

    function toggleArchiveView() {
        const v = document.getElementById('view-archive');
        const t = document.getElementById('view-tasks');

        if (document.getElementById('view-archive').classList.contains('active')) {
            document.getElementById('view-archive').classList.remove('active');
            document.getElementById('view-tasks').classList.add('active');
            document.querySelector('.bottom-nav').style.display = 'flex';
        } else {
            document.getElementById('view-tasks').classList.remove('active');
            document.getElementById('view-archive').classList.add('active');
            fetchArchivedTasks();
        }
    }

    function fetchArchivedTasks() {
        const list = document.getElementById('archive-list');
        if (list) list.innerHTML = '<div style="text-align:center; padding:20px; color:#999;">Loading...</div>';
        google.script.run.withSuccessHandler(renderArchiveTasks).getArchivedTasks();
    }

    function renderArchiveTasks(tasks) {
        const container = document.getElementById('archive-list');
        if (!container) return;
        container.innerHTML = '';

        if (!tasks || tasks.length === 0) {
            container.innerHTML = '<div style="text-align:center; padding:20px; color:#CCC;">„Ç¢„Éº„Ç´„Ç§„Éñ„Åï„Çå„Åü„Çø„Çπ„ÇØ„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì</div>';
            return;
        }

        const incomplete = tasks.filter(t => t.status !== 'ÂÆå‰∫Ü');
        const complete = tasks.filter(t => t.status === 'ÂÆå‰∫Ü');

        // Helper to create list
        const createSection = (title, listId, items, isDone) => {
            const sec = document.createElement('div');
            sec.className = 'section-container' + (isDone ? ' completed' : '');

            const count = items.length;
            sec.innerHTML = `
        <div class="section-header" onclick="toggleSection('${listId}')">
             <div style="color:${isDone ? '#AAA' : '#555'}; font-weight:bold;">${title} (${count})</div>
          </div>
        <div id="list-${listId}" class="list-content"></div>
      `;
            container.appendChild(sec);

            const listDiv = sec.querySelector(`#list-${listId}`);
            const innerDiv = document.createElement('div'); // Transition Wrapper
            listDiv.appendChild(innerDiv);

            items.forEach(t => {
                const wrapper = document.createElement('div');
                wrapper.className = 'task-wrapper';
                wrapper.innerHTML = `
        <div class="task-actions">
               <div class="action-btn unarchive" onclick="doUnarchiveTask('${t.id}')" style="background:#8D6E63;">‚Ü©</div>
               <div class="action-btn delete" onclick="doDeleteTask('${t.id}')">‚ùå</div>
          </div>
        <div class="task-item" style="background:#F9F9F9; opacity:0.9;">
          <div style="flex:1;">
            <div style="font-weight:bold; color:#555; text-decoration:${isDone ? 'line-through' : 'none'};">${t.name}</div>
            <div style="font-size:0.8em; color:#999;">${t.dueDate || ''}</div>
          </div>
        </div>
      `;
                const item = wrapper.querySelector('.task-item');
                addSwipeLogic(item);
                innerDiv.appendChild(wrapper);
            });
        };

        if (incomplete.length > 0) createSection('Êú™ÂÆå‰∫Ü', 'arc-inc', incomplete, false);
        if (complete.length > 0) createSection('ÂÆå‰∫Ü', 'arc-com', complete, true);
    }
    /* --- HABITS --- */
    function fetchHabits(dateStr) {
        const root = document.getElementById('habit-sections-root');
        if (root) root.style.opacity = '0.4';
        google.script.run.withSuccessHandler((data) => {
            if (root) root.style.opacity = '1.0';
            renderHabits(data);
        }).getHabitStatus(dateStr);
    }

    function initDateStrip() {
        const strip = document.getElementById('calendar-strip');
        strip.innerHTML = '';
        const days = ['Êó•', 'Êúà', 'ÁÅ´', 'Ê∞¥', 'Êú®', 'Èáë', 'Âúü'];
        const today = new Date();

        for (let i = 6; i >= 0; i--) {
            const d = new Date(); d.setDate(today.getDate() - i);
            const isToday = i === 0;
            const ymd = d.toLocaleDateString('en-CA');

            const el = document.createElement('div');
            el.className = 'date-item' + (isToday ? ' active' : '');
            el.onclick = () => {
                document.querySelectorAll('.date-item').forEach(e => e.classList.remove('active'));
                el.classList.add('active');
                currentHabitDate = ymd;
                fetchHabits(ymd);
            };
            el.innerHTML = `<div class="date-label">${days[d.getDay()]}</div><div class="date-num">${d.getDate()}</div>`;
            strip.appendChild(el);
        }
    }

    function renderHabits(data) {
        // Cache Logic
        habitDataCache = data;
        if (data.serverDate) { todayYear = data.serverDate.year; todayMonth = data.serverDate.month; }
        if (data.monthlyLogs) {
            const key = `${todayYear}-${todayMonth}`;
            Object.keys(data.monthlyLogs).forEach(hName => {
                if (!habitCalendarCache[hName]) habitCalendarCache[hName] = {};
                habitCalendarCache[hName][key] = data.monthlyLogs[hName];
            });
        }

        const root = document.getElementById('habit-sections-root');
        if (!root) return;
        root.innerHTML = '';

        // Ensure sections exist (SSR fallback)
        const sections = (data.sections && data.sections.length > 0) ? data.sections : [
            { id: 'sec_morning', name: 'Êúù', order: 1 },
            { id: 'sec_afternoon', name: 'Êòº', order: 2 },
            { id: 'sec_evening', name: 'Â§ú', order: 3 },
            { id: 'sec_other', name: '„Åù„ÅÆ‰ªñ', order: 4 }
        ];

        // Render Sections
        sections.forEach(sec => {
            const div = document.createElement('div');
            div.className = 'section-habit';
            div.id = 'sec-wrapper-' + sec.id;
            div.innerHTML = `
      <div class="section-header" onclick="toggleHabitSection('${sec.id}')">
           <div>${sec.name} <span id="count-${sec.id}" style="font-size:0.9em; opacity:0.8;"></span></div>
           <div class="toggle-icon">‚àß</div>
      </div>
    <div id="list-habit-${sec.id}" class="habit-list-container">
      <div><!-- Inner --></div>
    </div>
  `;
            root.appendChild(div);
        });

        // Clear Checked
        const checkedInner = document.querySelector('#list-habit-checked > div');
        if (checkedInner) checkedInner.innerHTML = '';
        const countChecked = document.getElementById('count-habit-checked');
        if (countChecked) countChecked.innerText = '0';
        let checkedCount = 0;

        if (!data.habits) { updateHabitSectionCounts(); return; }

        data.habits.forEach(h => {
            // 2-Level Logic: Only Status 2 (Offense Done) moves to "Completed" area.

            const isAdvanced = !!h.offenseTitle;
            // Robust Status Check (Handle string 'DONE' or number)
            let s = h.status;
            if (s === 'DONE') s = (isAdvanced ? 2 : 1); // Infer numeric status if string
            else s = parseInt(s || 0);

            // Re-assign sanitized status to h for createHabitCard usage
            h.status = s;

            const isDone = isAdvanced ? (s === 2) : (s >= 1);

            if (isDone) {
                const div = createHabitCard(h, true); // Pass resolved isDone state
                div.classList.add('done'); // FORCE ADD CLASS
                const target = document.querySelector('#list-habit-checked > div');
                if (target) target.appendChild(div);
                checkedCount++;
            } else {
                // Find section
                let targetSecId = h.sectionId || 'sec_other';
                // Verify section exists in DOM
                if (!document.getElementById('list-habit-' + targetSecId)) targetSecId = 'sec_other';

                const div = createHabitCard(h, false); // Not "fully done" (might be status 1 but staying in list)
                // Append to section
                const container = document.querySelector(`#list-habit-${targetSecId} > div`);
                if (container) container.appendChild(div);
            }
        });

        updateHabitSectionCounts(); // Initial calculations

        const checkedSec = document.getElementById('sec-wrapper-checked');
        if (checkedSec) {
            if (checkedCount > 0) {
                checkedSec.style.display = 'block';
                if (countChecked) countChecked.innerText = '(' + checkedCount + ')';
            } else {
                checkedSec.style.display = 'none';
            }
        }
    }

    function createHabitCard(h, isMovedToDone) {
        const div = document.createElement('div');
        // Status 1 (Offense Unlocked) gets special style
        const isAdvancedActive = (h.status === 1 && h.offenseTitle);

        div.className = 'habit-item' + (isMovedToDone ? ' done' : '') + (isAdvancedActive ? ' status-advanced' : '');
        div.onclick = () => openHabitDetail(h);

        // Data attributes for Toggle Logic
        div.dataset.status = h.status || 0;
        div.dataset.offenseTitle = h.offenseTitle || '';
        div.dataset.encourage = h.offenseTitle ? 'true' : 'false'; // Flag for logic

        let iconContent = 'üíß';
        if (h.icon) {
            const isMaterial = /^[a-z0-9_]+$/.test(h.icon);
            if (isMaterial) {
                iconContent = `<span class="material-symbols-rounded" style="font-size:24px;">${h.icon}</span>`;
            } else {
                iconContent = `<span style="font-size:24px;">${h.icon}</span>`;
            }
        }

        // Title Logic: Status 1 shows Offense Title
        const displayTitle = (isAdvancedActive && h.offenseTitle) ? h.offenseTitle : h.name;

        // Effect for Offense? Red Icon BG? (Handled by CSS .status-advanced .habit-icon)

        div.innerHTML = `
        <div class="habit-icon">${iconContent}</div>
           <div class="habit-info">
              <div class="habit-name">${displayTitle}</div>
           </div>
           <div class="habit-stats-right">
              <div style="font-size:16px; font-weight:bold; color:var(--primary)">${h.streak || 0}Êó•</div>
              <div style="font-size:10px; color:#999">ÁèæÂú®„ÅÆÈÄ£Á∂ö</div>
           </div>
           <div class="habit-check-area" onclick="event.stopPropagation(); toggleHabit(this, '${h.name}')">
              <div class="check-circle"></div>
           </div>
      `;
        // Store Section ID for return
        div.dataset.sectionId = h.sectionId || 'sec_other';
        return div;
    }

    function toggleHabit(checkEl, habitName) {
        const item = checkEl.closest('.habit-item');
        if (!item) return;

        const currentStatus = parseInt(item.dataset.status || 0);
        const offenseTitle = item.dataset.offenseTitle || '';
        const hasLevels = !!offenseTitle;

        let newStatus = 0;
        if (hasLevels) {
            // 0 (Undone) -> 1 (Defense Done / Offense Unlocked) -> 2 (All Done) -> 0
            if (currentStatus === 0) newStatus = 1;
            else if (currentStatus === 1) newStatus = 2;
            else newStatus = 0;
        } else {
            // Simple: 0 -> 1 -> 0
            newStatus = (currentStatus === 0) ? 1 : 0;
        }

        processHabitToggle(item, habitName, newStatus, hasLevels);
    }

    function processHabitToggle(item, habitName, newStatus, isAdvanced) {
        const oldStatus = parseInt(item.dataset.status || 0);

        // --- 1. Optimistic Streak Update ---
        const wasDone = oldStatus >= 1;
        const isDoneNow = newStatus >= 1;

        if (wasDone !== isDoneNow) {
            const streakEl = item.querySelector('.habit-stats-right > div:first-child');
            if (streakEl) {
                let currentStreak = parseInt(streakEl.innerText) || 0;
                if (isDoneNow) currentStreak++;
                else currentStreak = Math.max(0, currentStreak - 1);
                streakEl.innerText = currentStreak + 'Êó•';
            }
        }

        // 1. Optimistic Update
        item.dataset.status = newStatus;

        // Update Classes
        item.classList.remove('status-advanced', 'done');
        if (isAdvanced) {
            if (newStatus === 1) item.classList.add('status-advanced');
            if (newStatus === 2) item.classList.add('done');
        } else {
            if (newStatus >= 1) item.classList.add('done');
        }

        // 2. Journal Logic (if turning ON)
        if (newStatus > 0 && (habitName.endsWith('Êó•Ë®ò') || habitName === 'Áù°Áú†ÊôÇÈñìË®òÈå≤')) {
            openJournalModal(habitName, item);
        }
        // --- Optimistic Move Logic ---
        const isDone = isAdvanced ? (newStatus === 2) : (newStatus >= 1);

        let targetListId;
        if (isDone) {
            targetListId = 'list-habit-checked';
            item.classList.add('done');
        } else {
            const secId = item.dataset.sectionId || 'sec_other';
            targetListId = 'list-habit-' + secId;
        }

        const currentParentId = item.parentElement.parentElement ? item.parentElement.parentElement.id : '';

        if (currentParentId && currentParentId !== targetListId) {
            const targetContainer = document.querySelector('#' + targetListId + ' > div');

            if (targetContainer) {
                // Animation
                item.style.transition = 'all 0.3s ease';
                item.style.opacity = '0';
                item.style.transform = 'scale(0.9)';

                setTimeout(() => {
                    targetContainer.appendChild(item);
                    updateHabitSectionCounts();

                    requestAnimationFrame(() => {
                        item.style.opacity = '1';
                        item.style.transform = 'scale(1)';
                    });
                }, 300);
            } else {
                updateHabitSectionCounts();
            }
        } else {
            updateHabitSectionCounts();
        }

        // Immediate Count Update
        updateHabitSectionCounts();


        // 4. Server Call
        console.log(`Toggling ${habitName} to ${newStatus}`);
        google.script.run.withSuccessHandler(() => {
            // Success
        }).logHabit(currentHabitDate, habitName, newStatus);
    }

    function openJournalModal(name, item) {
        // Simple stub if missing, or use existing if defined (check later)
        // I recall openJournalModal being discussed/used.
        // If it's not defined, this will error. 
        // Let's assume it IS defined or I need to find it.
        // Actually, Step 12649 view didn't show it in 1100-1600.
        // Step 12501 fixed `closeJournalModal`, so `openJournalModal` must be nearby or missing too.
        // I will search for it first? No, risk of delay.
        // I'll define a basic one if not found later.

        const modal = document.getElementById('journal-modal');
        if (modal) {
            pendingJournalItem = item;
            pendingJournalName = name;
            document.getElementById('journal-input').value = '';
            modal.classList.add('open');
        }
    }


    let pendingJournalItem = null;
    let pendingJournalName = '';

    function closeJournalModal(saved) {
        document.getElementById('journal-modal').classList.remove('open');
        if (!saved && pendingJournalItem) {
            // Cancelled: Revert the checkbox visually
            // This logic is now handled by processHabitToggle if newStatus is 0
            // For now, just clear pending item.
            pendingJournalItem = null;
            // CSS Grid Transition
            // list.classList.toggle('collapsed'); // Assuming list is global or querySelector needed
        }
    }

    function markSectionDirty(input) {
        // Can use valid visual cue
        input.style.backgroundColor = '#FFF8E1';
    }

    function updateHabitSectionCounts() {
        const sections = habitDataCache ? habitDataCache.sections : [];
        sections.forEach(sec => {
            const listId = 'list-habit-' + sec.id;
            const wrapperId = 'sec-wrapper-' + sec.id;
            const countId = 'count-' + sec.id;

            const listContainer = document.querySelector('#' + listId + ' > div');
            if (!listContainer) return;

            const count = listContainer.children.length;
            const countEl = document.getElementById(countId);
            const wrapperEl = document.getElementById(wrapperId);

            if (countEl) countEl.innerText = '(' + count + ')';

            // Auto Hide Logic (keep wrapper in DOM but hide)
            if (wrapperEl) {
                if (count === 0) {
                    wrapperEl.style.display = 'none';
                } else {
                    wrapperEl.style.display = 'block';
                }
            }
        });
    }

    // --- HABIT DETAIL & CALENDAR ---
    function openHabitDetail(habit) {
        currentDetailHabit = habit;

        // Ensure valid date references to prevent 1970 bug
        const d = new Date();
        if (!todayYear || isNaN(todayYear)) {
            todayYear = d.getFullYear();
            todayMonth = d.getMonth() + 1;
        }

        // Initialize current detail view date
        currentDetailYear = todayYear;
        currentDetailMonth = todayMonth;

        // Extra safety: if somehow still invalid, force defaults
        if (!currentDetailYear) currentDetailYear = 2025;
        if (!currentDetailMonth) currentDetailMonth = 1;

        const iconEl = document.querySelector('#habit-detail-modal .detail-icon');
        if (iconEl) {
            if (habit.icon) {
                const isMaterial = /^[a-z0-9_]+$/.test(habit.icon);
                if (isMaterial) {
                    iconEl.innerHTML = `<span class="material-symbols-rounded" style="color:var(--primary); font-size:40px;">${habit.icon}</span>`;
                } else {
                    iconEl.innerHTML = `<span style="font-size:40px;">${habit.icon}</span>`;
                }
            } else {
                iconEl.innerHTML = 'üíß';
            }
        }

        const titleEl = document.getElementById('detail-name');
        if (titleEl) titleEl.innerText = habit.name;

        const timeEl = document.getElementById('detail-time');
        if (timeEl) timeEl.innerText = 'ÊâÄË¶ÅÊôÇÈñì: ' + (habit.time || 'Êú™Ë®≠ÂÆö');

        const descEl = document.getElementById('detail-desc');
        if (descEl) descEl.innerText = habit.benefit || 'ÁøíÊÖ£„ÇíÁ∂ö„Åë„Å¶ÁõÆÊ®ô„ÇíÈÅîÊàê„Åó„Åæ„Åó„Çá„ÅÜ';

        const streakEl = document.getElementById('detail-streak');
        if (streakEl) streakEl.innerText = `${habit.streak || 0} Êó•`;

        const rateEl = document.getElementById('detail-rate');
        if (rateEl) rateEl.innerText = `${habit.rate30 || 0}% `;

        // Journal Logs Logic
        const logContainer = document.getElementById('detail-journal-logs-container');
        if (logContainer) {
            logContainer.innerHTML = ''; // Clear previous

            if (habit.name.endsWith('Êó•Ë®ò') || habit.name === 'Áù°Áú†ÊôÇÈñìË®òÈå≤') {
                logContainer.innerHTML = '<div style="text-align:center; padding:20px; color:#999;">Loading...</div>';
                google.script.run.withSuccessHandler(renderJournalLogs).getHabitTextLogs(habit.name);
            }
        }

        document.getElementById('habit-detail-modal').classList.add('open');

        // Initial Calendar Render with Prefetch (New Logic)
        changeDetailMonth(0);
    }

    function renderJournalLogs(logs) {
        const container = document.getElementById('detail-journal-logs-container');
        if (!container) return;

        if (!logs || logs.length === 0) {
            container.innerHTML = '<div style="color:#999; text-align:center; font-size:12px;">Ë®òÈå≤„ÅØ„Åæ„Å†„ÅÇ„Çä„Åæ„Åõ„Çì</div>';
            return;
        }

        container.innerHTML = '';
        logs.forEach(log => {
            const card = document.createElement('div');
            card.style.cssText = 'background:rgba(255,255,255,0.8); border-radius:12px; padding:15px; margin-bottom:10px; box-shadow:0 2px 5px rgba(0,0,0,0.05);';
            card.innerHTML = `
        <div style="font-size:12px; color:#888; margin-bottom:5px;">${log.date}</div>
          <div style="font-size:14px; color:#333; white-space:pre-wrap;">${log.text}</div>
      `;
            container.appendChild(card);
        });
    }

    function closeHabitDetail() {
        document.getElementById('habit-detail-modal').classList.remove('open');
    }

    // --- New Calendar Prefetching Logic ---

    function changeDetailMonth(offset) {
        let y = currentDetailYear;
        let m = currentDetailMonth + offset;

        // Handle wrapping
        if (m > 12) { m = 1; y++; }
        if (m < 1) { m = 12; y--; }

        // Future Restriction? (Optional: Allow viewing next month if pre-planning?)
        // Keeping strict restriction to not go beyond M+1 or Today?
        // User requested "adjacent months". Let's allow freely for now, or clamp to reasonable future.
        // Let's stick to simple wrapping.

        currentDetailYear = y;
        currentDetailMonth = m;

        document.getElementById('cal-month-label').innerText = `${y}Âπ¥ ${m}Êúà`;

        // Update Arrow Styles
        const btnNext = document.getElementById('btn-next-month');
        if (btnNext) {
            // Let's disable if > today? Or > today+1?
            // For now, simple standard arrows.
        }

        // Cache Check & Render
        const key = `${y}-${m}`;
        if (habitCalendarCache[currentDetailHabit.name] && habitCalendarCache[currentDetailHabit.name][key]) {
            renderGrid(habitCalendarCache[currentDetailHabit.name][key]);

            // Background Fetch (Prefetch neighbors)
            fetchCalendarData(y, m, false);
        } else {
            document.getElementById('detail-cal-grid').innerHTML = '<div style="padding:20px; text-align:center; color:#999;">Loading...</div>';
            fetchCalendarData(y, m, true);
        }
    }

    function fetchCalendarData(year, month, doRender) {
        google.script.run.withSuccessHandler(data => {
            // Merge Data (Multi-Month Response)
            const hName = currentDetailHabit.name;
            if (!habitCalendarCache[hName]) habitCalendarCache[hName] = {};

            Object.keys(data).forEach(k => {
                habitCalendarCache[hName][k] = data[k];
            });

            if (doRender) {
                const key = `${currentDetailYear}-${currentDetailMonth}`;
                // Render only if strictly matching the request, OR if the current view is covered by the response keys.
                // Best to check if the *currently viewing* month is in the cache now.
                if (habitCalendarCache[hName][key]) {
                    renderGrid(habitCalendarCache[hName][key]);
                } else {
                    renderGrid({});
                }
            }
        }).getHabitCalendar(currentDetailHabit.name, year, month);
    }

    function renderGrid(map) {
        const container = document.getElementById('detail-cal-grid');
        container.innerHTML = '';

        const year = currentDetailYear;
        const month = currentDetailMonth;

        // Headers
        ['Êó•', 'Êúà', 'ÁÅ´', 'Ê∞¥', 'Êú®', 'Èáë', 'Âúü'].forEach(d => {
            const c = document.createElement('div');
            c.className = 'cal-header-cell'; c.innerText = d;
            container.appendChild(c);
        });

        const daysInMonth = new Date(year, month, 0).getDate();
        const firstDay = new Date(year, month - 1, 1).getDay();

        for (let i = 0; i < firstDay; i++) container.appendChild(document.createElement('div'));

        const today = new Date();
        today.setHours(0, 0, 0, 0);

        const start = currentDetailHabit.startDate ? new Date(currentDetailHabit.startDate) : new Date('2024-01-01');
        start.setHours(0, 0, 0, 0);

        for (let d = 1; d <= daysInMonth; d++) {
            const cell = document.createElement('div');
            cell.className = 'cal-cell';
            cell.innerText = d;

            const current = new Date(year, month - 1, d);

            if (current > today) {
                cell.style.opacity = '0.3';
            } else if (current < start) {
                // Before Start
            } else {
                const status = map[d];
                // Status 2 = Offense Done (Red in Calendar per plan)
                // Status 1 = Defense Done (Green in Calendar)
                if (status === 2) {
                    cell.classList.add('status-advanced'); // Red
                } else if (status === 1) {
                    cell.classList.add('status-done'); // Green
                } else if (current.getTime() === today.getTime()) {
                    cell.classList.add('status-today-incomplete');
                } else {
                    cell.classList.add('status-failed');
                }
            }
            container.appendChild(cell);
        }
    }

    // --- SETTINGS LOGIC ---
    let hsCurrentIcon = '';
    const popularIcons = [];

    function openHabitSettings() {
        if (!currentDetailHabit) return;
        document.getElementById('habit-settings-modal').style.display = 'flex';
        document.getElementById('hs-name').value = currentDetailHabit.name;
        document.getElementById('hs-time').value = currentDetailHabit.time || '';
        document.getElementById('hs-benefit').value = currentDetailHabit.benefit || '';

        // Advanced Fields
        document.getElementById('hs-offense-title').value = currentDetailHabit.offenseTitle || '';
        document.getElementById('hs-offense-time').value = currentDetailHabit.offenseTime || '';

        // Toggle State
        const hasAdvanced = !!(currentDetailHabit.offenseTitle || currentDetailHabit.offenseTime);
        document.getElementById('hs-advanced-toggle').checked = hasAdvanced;
        toggleAdvancedSettings(); // Update visibility

        // Icon Init
        hsCurrentIcon = currentDetailHabit.icon || '';
        updateIconPreview();

        // Populate Sections
        const sel = document.getElementById('hs-section');
        sel.innerHTML = '';
        const sections = habitDataCache ? habitDataCache.sections : [];
        sections.forEach(s => {
            const opt = document.createElement('option');
            opt.value = s.id;
            opt.innerText = s.name;
            if (s.id === currentDetailHabit.sectionId) opt.selected = true;
            sel.appendChild(opt);
        });
    }

    function toggleAdvancedSettings() {
        const isChecked = document.getElementById('hs-advanced-toggle').checked;
        const container = document.getElementById('hs-advanced-settings');
        container.style.display = isChecked ? 'block' : 'none';
    }

    function updateIconPreview() {
        const preview = document.getElementById('hs-icon-preview');
        // Simple logic: if in material list, render as material icon. Else assume emoji text.
        // Or cleaner: check if string matching regex for emoji?
        // Easiest is checking material list presence, but that might be slow if list is huge (it is).
        // Material icons are usually snake_case words. Emojis are unicode.
        // Let's assume regex /^[a-z0-9_]+$/ is material.

        const isMaterial = hsCurrentIcon && /^[a-z0-9_]+$/.test(hsCurrentIcon);

        if (hsCurrentIcon) {
            if (isMaterial) {
                preview.innerHTML = `<span class="material-symbols-rounded" style="color:var(--primary);">${hsCurrentIcon}</span>`;
            } else {
                preview.innerHTML = `<span style="font-size:24px;">${hsCurrentIcon}</span>`;
            }
        } else {
            preview.innerHTML = `<span class="material-symbols-rounded" style="color:#ccc;">add_reaction</span>`;
        }
    }

    function closeHabitSettings() {
        document.getElementById('habit-settings-modal').style.display = 'none';
    }

    function saveHabitDefinition() {
        const newName = document.getElementById('hs-name').value;
        const newSec = document.getElementById('hs-section').value;
        const newTime = document.getElementById('hs-time').value;
        const newBenefit = document.getElementById('hs-benefit').value;

        // Logic: If toggle is OFF, should we clear the offense fields?
        // Maybe? Or just ignore them? 
        // Better to clear them if user explicitly disabled.
        // But if user just hides and shows, they might want to keep.
        // For now, save what is in the fields if toggle is ON?
        // Actually, if toggle ID is unchecked, we should probably save empty strings for offense.

        const isAdvanced = document.getElementById('hs-advanced-toggle').checked;
        const newOffense = isAdvanced ? document.getElementById('hs-offense-title').value : '';
        const newOffenseTime = isAdvanced ? document.getElementById('hs-offense-time').value : '';

        if (!newName) return;

        // Visual Feedback
        const btn = document.querySelector('#habit-settings-modal .btn-save');
        const originalText = btn ? btn.innerText : '‰øùÂ≠ò';
        if (btn) {
            btn.innerText = '‰øùÂ≠ò‰∏≠...';
            btn.disabled = true;
        }

        google.script.run.withSuccessHandler(() => {
            closeHabitSettings();
            // closeHabitDetail(); // Kept open as requested
            fetchHabits();

            if (btn) {
                btn.innerText = originalText;
                btn.disabled = false;
            }
        }).withFailureHandler((e) => {
            alert('‰øùÂ≠ò„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ' + e);
            if (btn) {
                btn.innerText = originalText;
                btn.disabled = false;
            }
        }).saveHabitDefinition(currentDetailHabit.name, newName, newSec, hsCurrentIcon, newTime, newBenefit, newOffense, newOffenseTime);
    }

    // --- ICON PICKER ---
    // --- ICON PICKER ---
    let iconTab = 'material'; // 'material' | 'emoji'
    let currentIconList = [];

    function openIconPicker() {
        document.getElementById('icon-picker-modal').style.display = 'flex';
        // Reset to Material default or keep last? Let's reset for now or keep consistency.
        switchIconTab('material');
    }

    function closeIconPicker() {
        document.getElementById('icon-picker-modal').style.display = 'none';
        document.getElementById('icon-search').value = ''; // Clear search
    }

    function switchIconTab(tab) {
        iconTab = tab;
        const tabMat = document.getElementById('tab-material');
        const tabEmo = document.getElementById('tab-emoji');
        const input = document.getElementById('icon-search');

        if (tab === 'material') {
            tabMat.style.background = 'white';
            tabMat.style.fontWeight = 'bold';
            tabMat.style.color = '#333';
            tabEmo.style.background = 'transparent';
            tabEmo.style.fontWeight = 'normal';
            tabEmo.style.color = '#666';
            input.placeholder = '„Ç¢„Ç§„Ç≥„É≥„ÇíÊ§úÁ¥¢ (‰æã: home, account)...';
            renderIconGrid(materialIconsList.slice(0, 100)); // Default view
        } else {
            tabMat.style.background = 'transparent';
            tabMat.style.fontWeight = 'normal';
            tabMat.style.color = '#666';
            tabEmo.style.background = 'white';
            tabEmo.style.fontWeight = 'bold';
            tabEmo.style.color = '#333';
            input.placeholder = 'ÁµµÊñáÂ≠ó„ÇíÊ§úÁ¥¢ (‰æã: smile, cat)...';
            // Render first 100 emojis
            const previewList = emojiList.slice(0, 100).map(e => e[0]);
            renderIconGrid(previewList);
        }
    }

    function renderIconGrid(icons) {
        const grid = document.getElementById('icon-grid');
        grid.innerHTML = '';
        icons.forEach(icon => {
            const div = document.createElement('div');
            div.style.cssText = 'height:50px; background:#f9f9f9; border-radius:8px; display:flex; align-items:center; justify-content:center; cursor:pointer; font-size:24px; color:#555;';
            div.onclick = () => selectIcon(icon);

            // Check if it's an emoji (simple length check or regex? actually just check if it's in material list?)
            // Faster: if iconTab is emoji, render text. If material, render span class.

            if (iconTab === 'material') {
                div.innerHTML = `<span class="material-symbols-rounded">${icon}</span>`;
            } else {
                div.innerHTML = `<span>${icon}</span>`;
            }

            grid.appendChild(div);
        });
    }

    function selectIcon(icon) {
        hsCurrentIcon = icon;
        updateIconPreview();
        closeIconPicker();
    }

    function filterIcons(query) {
        const q = query.toLowerCase();

        if (iconTab === 'material') {
            if (!q) { renderIconGrid(materialIconsList.slice(0, 100)); return; }
            const filtered = materialIconsList.filter(i => i.includes(q)).slice(0, 100);
            renderIconGrid(filtered);
        } else {
            // Emojis: [char, keywords]
            if (!q) {
                renderIconGrid(emojiList.slice(0, 100).map(e => e[0]));
                return;
            }
            const filtered = emojiList
                .filter(e => e[1].includes(q)) // Search keywords
                .map(e => e[0]) // Extract char
                .slice(0, 100);
            renderIconGrid(filtered);
        }
    }

    let sectionSortable = null;

    // --- SECTIONS ---
    function openSectionManager() {
        document.getElementById('section-manager-modal').style.display = 'flex';
        renderSectionManagerList();

        // Init Sortable
        const el = document.getElementById('sm-list');
        if (sectionSortable) sectionSortable.destroy();
        sectionSortable = Sortable.create(el, {
            handle: '.section-handle', // Drag handle class
            animation: 150
        });
    }

    function closeSectionManager() {
        document.getElementById('section-manager-modal').style.display = 'none';
        if (sectionSortable) {
            sectionSortable.destroy();
            sectionSortable = null;
        }
    }

    function renderSectionManagerList() {
        const root = document.getElementById('sm-list');
        root.innerHTML = '';

        const sections = habitDataCache ? habitDataCache.sections : [];

        sections.forEach((s, idx) => {
            const row = document.createElement('div');
            row.className = 'section-row';
            row.style.display = 'flex';
            row.style.gap = '10px';
            row.style.marginBottom = '10px';
            row.dataset.id = s.id;

            row.innerHTML = `
        <div class="section-handle" style = "cursor:move; padding-top:5px; padding-right:5px; color:#aaa;" >‚ò∞</div >
          <input value="${s.name}" class="input-std" style="margin:0; flex:1;" onchange="markSectionDirty(this)">
            <div style="cursor:pointer; color:red; padding-top:5px;" onclick="deleteSectionRow(this)">‚úï</div>
            `;
            root.appendChild(row);
        });
    }

    function toggleHabitSection(secId) {
        const list = document.getElementById('list-habit-' + secId);
        const wrapper = document.getElementById('sec-wrapper-' + secId);
        const icon = wrapper.querySelector('.toggle-icon');

        if (list.classList.contains('collapsed')) {
            list.classList.remove('collapsed');
            icon.style.transform = 'rotate(0deg)';
        } else {
            list.classList.add('collapsed');
            icon.style.transform = 'rotate(180deg)';
        }
    }

    function addSectionRow() {
        const root = document.getElementById('sm-list');
        const row = document.createElement('div');
        row.className = 'section-row';
        row.style.gap = '10px';
        row.style.marginBottom = '10px';
        row.dataset.id = 'new-' + Date.now();

        row.innerHTML = `
    <div class="section-handle" style="cursor:move; padding-top:5px; padding-right:5px; color:#aaa;">‚ò∞</div>
    <input value="" placeholder="Êñ∞„Åó„ÅÑ„Çª„ÇØ„Ç∑„Éß„É≥" class="input-std" style="margin:0; flex:1;" onchange="markSectionDirty(this)">
    <div style="cursor:pointer; color:red; padding-top:5px;" onclick="deleteSectionRow(this)">‚úï</div>
  `;
        root.appendChild(row);
    }

    function deleteSectionRow(el) {
        if (confirm('„Åì„ÅÆ„Çª„ÇØ„Ç∑„Éß„É≥„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü')) {
            el.closest('.section-row').remove();
        }
    }

    function saveSections() {
        const rows = document.querySelectorAll('#sm-list .section-row');
        const sections = [];
        rows.forEach((r, idx) => {
            const id = r.dataset.id.startsWith('new-') ? 'sec_' + Math.random().toString(36).substr(2, 9) : r.dataset.id;
            const name = r.querySelector('input').value;
            if (name) {
                sections.push({ id: id, name: name });
            }
        });

        google.script.run.withSuccessHandler(() => {
            closeSectionManager();
            fetchHabits();
        }).saveHabitSections(sections);
    }

    // --- GOALS AND DASHBOARD ---

    function fetchGoals() {
        const activeTab = document.querySelector('.nav-item.active');
        const isRoadmap = activeTab && activeTab.innerText.includes('Roadmap');

        if (isRoadmap) {
            renderRoadmap();
        }
    }

    function renderGoalsTab() {
        // Deleted
    }

    /* --- ROADMAP RENDERING (Updated UI) --- */
    function renderRoadmap() {
        const container = document.getElementById('goal-list-container');
        if (!container) return;

        // Show spinner only if empty
        if (!container.hasChildNodes()) {
            container.innerHTML = '<div class="loading-spinner"></div>';
        }

        google.script.run.withSuccessHandler(goals => {
            window.loadedGoals = goals; // Keep global sync
            renderRoadmapFromData(goals);
        }).withFailureHandler(err => {
            container.innerHTML = `<div style="color:red; padding:20px;">Error: ${err}</div>`;
        }).getGoalsV2();
    }

    function renderRoadmapFromData(goals) {
        const container = document.getElementById('goal-list-container');
        if (!container) return;

        if (!goals || goals.length === 0) {
            container.innerHTML = `
                <div style="text-align:center; padding:40px; color:#aaa;">
                    <div style="font-size:40px; margin-bottom:10px;">üó∫Ô∏è</div>
                    <div>No goals found.</div>
                </div>
            `;
            return;
        }

        let html = '';
        goals.forEach(g => {
            if (g.id.startsWith('error')) return;

            const current = Number(g.metricCurrent) || 0;
            const target = Number(g.metricTarget) || 1;
            const percent = Math.min(100, Math.max(0, (current / target) * 100));

            // Calculate remaining days
            let remaining = '';
            if (g.endDate) {
                const today = new Date();
                const end = new Date(g.endDate);
                const diffTime = end - today;
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                if (diffDays >= 0) remaining = `ÊÆã„Çä ${diffDays} Êó•`;
                else remaining = 'ÊúüÈôêÂàá„Çå';
            }

            // Card HTML
            html += `
                <div class="card-glass goal-card" onclick="openGoalDetail('${g.id}')">
                    <div style="display:flex; justify-content:space-between; align-items:flex-start; margin-bottom:8px;">
                        <div class="goal-title">${g.title}</div>
                        <!-- Log Button (Stop Propagation) -->
                        <div style="padding:5px; background:rgba(0,0,0,0.05); border-radius:50%;" 
                             onclick="event.stopPropagation(); openProgressModal('${g.id}', ${current}, '${g.title}')">
                            <span class="material-symbols-rounded" style="font-size:18px; color:#555;">add</span>
                        </div>
                    </div>
                    
                    <div class="goal-vision">${g.vision || ''}</div>
                    
                    <div style="display:flex; justify-content:space-between; align-items:flex-end; margin-top:15px; margin-bottom:5px;">
                        <div style="font-size:12px; color:#666;">ÁèæÂú®: <span style="font-weight:bold; color:#333;">${current}</span> <span style="font-size:10px;">${g.metricLabel || ''}</span></div>
                        <div style="font-size:12px; color:#999;">ÁõÆÊ®ô: <span style="font-weight:bold;">${target}</span> <span style="font-size:10px;">${g.metricLabel || ''}</span></div>
                    </div>
                    
                    <div class="progress-container" style="height:10px; background:#f0f0f0;">
                        <div class="progress-bar" style="width:${percent}%; background:#2196F3;"></div>
                    </div>
                    
                    <div style="display:flex; justify-content:space-between; margin-top:10px; font-size:11px; color:#999;">
                         <div>${g.endDate ? 'üèÅ ' + g.endDate : ''}</div>
                         <div>${remaining}</div>
                    </div>
                </div>
            `;
        });
        container.innerHTML = html;
    }

    /* --- GOAL MODAL LOGIC (New) --- */
    function openGoalModal() {
        // Clear inputs
        document.getElementById('g-title').value = '';
        document.getElementById('g-vision').value = '';
        document.getElementById('g-metric-label').value = '';
        document.getElementById('g-metric-target').value = '';
        document.getElementById('g-metric-current').value = '';
        document.getElementById('g-start-date').value = new Date().toISOString().split('T')[0];
        document.getElementById('g-end-date').value = '';

        document.getElementById('goal-modal').classList.add('open');
        document.getElementById('goal-modal').style.display = 'flex'; // Force visibility
    }

    function closeGoalModal() {
        document.getElementById('goal-modal').classList.remove('open');
        document.getElementById('goal-modal').style.display = 'none'; // Force hide
    }

    function saveGoal() {
        const title = document.getElementById('g-title').value;
        const vision = document.getElementById('g-vision').value;
        const metric = document.getElementById('g-metric-label').value;
        const target = document.getElementById('g-metric-target').value;
        const current = document.getElementById('g-metric-current').value;
        const start = document.getElementById('g-start-date').value;
        const end = document.getElementById('g-end-date').value;

        if (!title || !metric || !target) {
            alert('„Çø„Ç§„Éà„É´„ÄÅÂçò‰Ωç„ÄÅÁõÆÊ®ôÂÄ§„ÅØÂøÖÈ†à„Åß„Åô');
            return;
        }

        closeGoalModal();

        // --- Optimistic UI Update ---
        const tempId = 'temp-' + Date.now();
        const tempGoal = {
            id: tempId,
            title: title,
            vision: vision,
            metricLabel: metric,
            metricTarget: Number(target),
            metricCurrent: Number(current) || 0,
            startDate: start,
            endDate: end,
            isOptimistic: true // Marker for UI if needed (e.g. gray out delete btn)
        };

        if (!window.loadedGoals) window.loadedGoals = [];
        // Add to top or bottom? Default seems to be appended or sorted. 
        // Let's add to top for visibility.
        window.loadedGoals.unshift(tempGoal);
        renderRoadmapFromData(window.loadedGoals);

        // --- Server Sync ---
        google.script.run.withSuccessHandler(() => {
            // Re-fetch true data to get real ID and consistent sort
            renderRoadmap();
        }).createGoal(title, vision, metric, Number(target), Number(current), start, end);
    }

    let currentMeasurementGoalId = null;

    function openMeasurementModal(goalId, metricName, goalTitle) {
        currentMeasurementGoalId = goalId;
        document.getElementById('mm-title').innerText = metricName;
        document.getElementById('mm-subtitle').innerText = goalTitle;
        document.getElementById('mm-value').value = '';
        document.getElementById('measurement-modal').classList.add('open');
        setTimeout(() => document.getElementById('mm-value').focus(), 100);
    }

    function closeMeasurementModal() {
        document.getElementById('measurement-modal').classList.remove('open');
        currentMeasurementGoalId = null;
    }

    function saveMeasurement() {
        const val = document.getElementById('mm-value').value;
        const comment = document.getElementById('mm-comment').value;

        if (!val) return;

        const idToLog = currentMeasurementGoalId;
        closeMeasurementModal();
        const dateStr = new Date().toLocaleDateString('en-CA');

        google.script.run.withSuccessHandler(() => {
            // Success
        }).logDailyMeasurement(idToLog, val, comment, dateStr);
    }

    /* --- DELETED WIZARD LOGIC --- */

    /* --- GOAL DETAIL LOGIC (Moved to Top) --- */

    /* --- PROGRESS LOGIC --- */
    let currentProgressGoalId = null;

    function openProgressModal(id, current, title) {
        currentProgressGoalId = id;
        document.getElementById('pm-title').innerText = 'ÈÄ≤Êçó„ÇíË®òÈå≤';
        document.getElementById('pm-subtitle').innerText = title;
        document.getElementById('pm-value').value = current; // Pre-fill current
        document.getElementById('pm-notes').value = '';

        const modal = document.getElementById('progress-modal');
        modal.classList.add('open');
        modal.style.display = 'flex'; // FORCE override any inline 'none'

        setTimeout(() => {
            const valInput = document.getElementById('pm-value');
            if (valInput) {
                valInput.focus();
                valInput.select();
            }
        }, 100);
    }


    function openProgressFromDetailPage() {
        if (!window.activeGoalDetailId || !window.activeGoalDetailData) {
            console.error('No active goal detail data found');
            return;
        }
        const g = window.activeGoalDetailData;
        const current = Number(g.metricCurrent) || 0;
        openProgressModal(g.id, current, g.title);
    }

    function closeProgressModal() {
        const modal = document.getElementById('progress-modal');
        modal.classList.remove('open');
        modal.style.display = 'none'; // FORCE hide
        currentProgressGoalId = null;
    }

    function saveGoalProgress() {
        const val = document.getElementById('pm-value').value;
        const notes = document.getElementById('pm-notes').value;

        if (val === '') { alert('Êï∞ÂÄ§„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ'); return; }

        const idToLog = currentProgressGoalId; // Capture ID before nulling

        // Close immediately for perceived speed
        closeProgressModal();

        const dateStr = new Date().toLocaleDateString('en-CA');

        google.script.run.withSuccessHandler((res) => {
            if (res !== 'Logged') {
                alert('„Ç®„É©„Éº: ' + res);
            }

            // 1. Refresh Roadmap Data (Silent)
            google.script.run.withSuccessHandler((goals) => {
                window.loadedGoals = goals;
                renderRoadmapFromData(goals);

                // 2. If Detail Page is open for this goal, refresh it
                if (window.activeGoalDetailId === idToLog) {
                    // Update Data Object
                    const updatedGoal = goals.find(g => g.id === idToLog);
                    if (updatedGoal) {
                        window.activeGoalDetailData = updatedGoal;
                        // Determine target calculation
                        const cur = Number(updatedGoal.metricCurrent) || 0;
                        const tgt = Number(updatedGoal.metricTarget) || 0;
                        const pct = (tgt > 0) ? Math.min(100, Math.max(0, (cur / tgt) * 100)) : 0;

                        // Direct DOM Update for Snapiness
                        document.getElementById('gd-current-val').innerText = cur + (updatedGoal.metricLabel || '');
                        document.getElementById('gd-progress-fill').style.width = pct + '%';

                        // Reload History
                        google.script.run.withSuccessHandler(window.renderGoalHistory).getGoalHistory(idToLog);
                    }
                }
            }).getGoalsV2();

        }).logGoalProgress(idToLog, Number(val), notes, dateStr);
    }

    /* --- EXPOSE TO GLOBAL (Fix for Scope Issues) --- */
    window.openGoalModal = openGoalModal;
    window.closeGoalModal = closeGoalModal;
    window.saveGoal = saveGoal;
    window.openMeasurementModal = openMeasurementModal;
    window.closeMeasurementModal = closeMeasurementModal;
    window.openProgressModal = openProgressModal;
    window.closeProgressModal = closeProgressModal;
    window.saveGoalProgress = saveGoalProgress;
    window.renderGoalsTab = renderGoalsTab;
    window.renderRoadmap = renderRoadmap;

    console.log("Functions exposed to window.");
    /* --- FIXED HABIT LOGIC (Overrides previous definitions) --- */

    function processHabitToggle(item, habitName, newStatus, isAdvanced, force) {
        // Journal Logic (Blocking)
        if (!force && newStatus > 0) {
            if (habitName === 'Áù°Áú†ÊôÇÈñìË®òÈå≤') {
                openSleepModal(habitName, item);
                return;
            }
            if (habitName.endsWith('Êó•Ë®ò')) {
                openJournalModal(habitName, item);
                return;
            }
        }

        const oldStatus = parseInt(item.dataset.status || 0);

        // --- 1. Optimistic Streak Update ---
        const wasDone = oldStatus >= 1;
        const isDoneNow = newStatus >= 1;

        if (wasDone !== isDoneNow) {
            const streakEl = item.querySelector('.habit-stats-right > div:first-child');
            if (streakEl) {
                let currentStreak = parseInt(streakEl.innerText) || 0;
                if (isDoneNow) currentStreak++;
                else currentStreak = Math.max(0, currentStreak - 1);
                streakEl.innerText = currentStreak + 'Êó•';
            }
        }

        // 1. Optimistic Update
        item.dataset.status = newStatus;

        // Update Classes
        item.classList.remove('status-advanced', 'done');
        if (isAdvanced) {
            if (newStatus === 1) item.classList.add('status-advanced');
            if (newStatus === 2) item.classList.add('done');
        } else {
            if (newStatus >= 1) item.classList.add('done');
        }

        // --- Optimistic Move Logic ---
        const isDone = isAdvanced ? (newStatus === 2) : (newStatus >= 1);

        let targetListId;
        if (isDone) {
            targetListId = 'list-habit-checked';
            item.classList.add('done');
        } else {
            const secId = item.dataset.sectionId || 'sec_other';
            targetListId = 'list-habit-' + secId;
        }

        const currentParentId = item.parentElement.parentElement ? item.parentElement.parentElement.id : '';

        if (currentParentId && currentParentId !== targetListId) {
            const targetContainer = document.querySelector('#' + targetListId + ' > div');
            if (targetContainer) {
                item.style.transition = 'all 0.3s ease';
                item.style.opacity = '0';
                item.style.transform = 'scale(0.9)';
                setTimeout(() => {
                    targetContainer.appendChild(item);
                    updateHabitSectionCounts();
                    requestAnimationFrame(() => {
                        // FIX: Do not force opacity 1 if done. Let CSS handle it, or match target.
                        // Best approach: clear inline opacity so CSS takes priority, 
                        // BUT for transition we need explicit value? 
                        // CSS transition handles it if we remove the inline style?
                        // Let's try explicitly setting correct target.
                        const isDoneClass = item.classList.contains('done');
                        item.style.opacity = isDoneClass ? '0.5' : '1';
                        item.style.transform = 'scale(1)';

                        // Clean up inline styles after transition to allow CSS hover/etc to work?
                        // If we leave it at 0.5, it overrides CSS 0.5 (same).
                        // If we later toggle back, we need to update.
                    });
                }, 300);
            } else {
                updateHabitSectionCounts();
            }
        } else {
            updateHabitSectionCounts();
        }
        updateHabitSectionCounts();

        console.log(`Toggling ${habitName} to ${newStatus}`);
        google.script.run.withSuccessHandler(() => {
            // Success
        }).logHabit(currentHabitDate, habitName, newStatus);
    }

    function openJournalModal(name, item) {
        const modal = document.getElementById('journal-modal');
        if (!modal) return;
        pendingJournalItem = item;
        pendingJournalName = name;
        document.getElementById('journal-input').value = '';
        const sub = document.getElementById('journal-subtitle');
        if (sub) sub.innerText = '‰ªäÊó•„ÅÆË®òÈå≤„ÇíÊÆã„Åó„Åæ„Åó„Çá„ÅÜ';
        const tit = document.getElementById('journal-title');
        if (tit) tit.innerText = name;
        const input = document.getElementById('journal-input');
        input.placeholder = '‰∏ÄË®Ä„É°„É¢...';

        modal.classList.add('open');
        modal.style.display = 'flex';
    }

    function closeJournalModal(saved) {
        const modal = document.getElementById('journal-modal');
        if (modal) {
            modal.classList.remove('open');
            modal.style.display = 'none';
        }
        if (!saved) {
            pendingJournalItem = null;
            pendingJournalName = '';
        }
    }

    function submitJournal() {
        if (!pendingJournalItem) return;
        const text = document.getElementById('journal-input').value;
        const name = pendingJournalName;
        const item = pendingJournalItem;

        closeJournalModal(true);
        // Force update to Done (Level 1)
        processHabitToggle(item, name, 1, false, true);

        google.script.run.logHabitText(currentHabitDate, name, text);
    }

    /* --- SLEEP MODAL LOGIC (NUCLEAR FIX 3: CLOCK UI) --- */

    function populateSleepTimes() {
        // Logic removed: Using native <input type="time">
    }

    function openSleepModal(name, item) {
        pendingJournalItem = item;
        pendingJournalName = name;

        // Default or Persisted values
        // If empty, set defaults.
        const s = document.getElementById('slp-time-start');
        const e = document.getElementById('slp-time-end');
        if (s && !s.value) s.value = '23:00';
        if (e && !e.value) e.value = '07:00';

        const modal = document.getElementById('sleep-modal');
        if (modal) {
            modal.classList.add('open');
            modal.style.display = 'flex';
        }
    }

    function closeSleepModal() {
        const modal = document.getElementById('sleep-modal');
        if (modal) {
            modal.classList.remove('open');
            modal.style.display = 'none';
        }
    }

    function commitSleepLog() {
        // Read Native Inputs
        const bedtime = document.getElementById('slp-time-start').value;
        const wakeup = document.getElementById('slp-time-end').value;

        // Validation
        if (!bedtime || !wakeup) {
            alert('ÊôÇÈñì„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ');
            return;
        }

        const item = pendingJournalItem;
        const name = pendingJournalName;

        closeSleepModal();
        processHabitToggle(item, name, 1, false, true);

        google.script.run.logSleep(currentHabitDate, bedtime, wakeup);
    }

    // Explicit global expose
    window.submitJournal = submitJournal;
    window.processHabitToggle = processHabitToggle;
    window.openSleepModal = openSleepModal;
    window.closeSleepModal = closeSleepModal;
    window.saveSleep = commitSleepLog;
    window.commitSleepLog = commitSleepLog;
    window.saveSleepLog = commitSleepLog; 
</script>